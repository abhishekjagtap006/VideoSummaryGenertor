 How's it going everyone and welcome back to another video today? We're going through the NumPy library which is considered to be kind of the fundamental package for all scientific computing and pythons. So it's a super super important library It's kind of the base for a lot of the other like major data science libraries and pythons so like pandas that I've done a video on before it builds pretty much like entirely off of the NumPy library So it's super important and kind of because it's important is because it's this like base The way we're going to do this video is I'm going to start out with kind of a background information on how NumPy works And I think really having that intuition is helpful for when you actually start writing code with it So we'll do the background information and then after that we'll jump into all sorts of useful Methods and ways you can utilize this library as far as actual code goes as always make sure to Smash that subscribe button through this video of thumbs up follow my Twitter Twitter Graham Insta Graham Twitter GitHub to Hit the bell for the notifications Throw this another thumbs up Yeah, to begin NumPy is a multi-dimensional array library So what that means is you can use NumPy to store all sorts of data in one-dimensional arrays two-dimensional arrays three-dimensional arrays four-dimensional arrays, etc. And so the common question you kind of ask or I'm commonly asked when You know you first bring up NumPy is why do you use NumPy over lists? So the main difference comes from the speed so lists they are very slow meanwhile NumPy is very fast and so why are lists low and NumPy fast? Well one reason is because NumPy uses fixed types So what that means is imagine we have this 3x4 matrix three rows four columns and It's all integer values and we're gonna kind of look at how those integer values differ between NumPy and lists so let's just zoom in on that five that's there in that matrix So our computers they don't see five they see binary that represents five and so This is the number five in binary and it's eight bits Which makes up a bite so our computers read information in bytes So when we use NumPy this eight this one bit five is actually bite of fault going to be Fasted to this int32 type which consists of four bytes And so it represents five in a total memory space of four bytes So in 32 and you also you can even specify so by default it's in 32 But you could even specify that you didn't need all four bytes to represent this value You could specify within NumPy that you want to maybe an in 16 which is 16 bits or two bytes or even if you have really small values Int8 which is just a single byte on the other hand with lists There's a lot more information you need to store as an integer so in In lists lists use a built-in int type for Python and so that built-in int type consists of four different things It consists of the object value Which you know has its own bits associated with it object type The reference count how many times that that integers been specifically like pointed at and the size of that integer value and So if we break this up into the actual binary that it represents we can take the object value and That's represented as a long which is like eight bytes the object type same deal reference count same deal and then the size I believe is a little bit smaller I think it's only four bytes, but as you can see that's a single integer within lists using the built-in int type It requires a lot more space than NumPy so basically the takeaway from this is That because NumPy uses less bytes of memory The computer can read less bytes of memory quicker obviously, so it's faster in that regard Another reason that I didn't specifically say is that When we're iterating through each item in a NumPy array we don't have to do type checking each time so in Python built-in lists You could have a list of like an integer then a float then a string then a Boolean And you'd have to check each element you're looking at what type it is, but NumPy we don't have to do that So another reason it's faster is that there's no type checking when iterating through objects Moving on another reason that NumPy is faster than lists is because NumPy utilizes Continuous memory. So what that means is imagine that this kind of array like Structure is our computer's memory so we could store Information in any one of these memory blocks So if we had a list the way that that would look in a list's memory is that our list would be kind of scattered around So maybe we have a list that takes up eight memory blocks The thing is that these memory blocks aren't Necessarily next to each other so you have some information here you have some information here you have a good amount of information in here Then you skip a block here here and skip two blocks. You have some information here. So it's all kind of scattered around So kind of if you have an item array what that looks like is that that array is actually just Or that list is just Containing pointers to the actual information that's scattered around our computer's memory And so it's just the all the information not right next to each other kind of you have to bounce around your computer's memory a bit And it's not super super fast to like rapidly go through and kind of Potentially form functions on all items at the time or subsets of the items NumPy array, however use it continuous memory. So all eight blocks in this case would be right next to each other and this has all sorts of advantages And also just to mention real quick you'd also like kind of have to Distort somehow where the start of that memory is and then like the total size and the type of memory block But it's a lot easier than this kind of pointer structure that's up here and so the benefits of NumPy using this contiguous memory are a couple of different things So the first benefit is that our CPUs or our computers have these SIMD vector processing units and so when this memory is all like right next to each other we can utilize this Unit and basically what SIMD stands for is single instruction multiple data So we could like if we have to do it in addition of like a lot of values Instead of just doing one addition at a time we can use this SIMD vector unit and basically perform Computations on all of these values at one time So it's quicker in that regard another reason it's quicker is that we more effectively utilize our cache So our kind of our quicker memory in our computer basically if we load in all these values We can keep them close to where we need to access them And like perform all sorts of operations while as in the list case you may be load in like half of this But then this other half because it's scattered around in different places you'd have to like go back and like reload that in To your cache like You know just be overall slower because you got to do more like longer memory lookups within your computer Okay, so we kind of went over some of the performance benefits, but how are the lists different from NumPy? Well lists we can do insertion, deletion, appending, concatenation, etc And we can also do those same exact things in NumPy I guess the big difference though is that within NumPy we can do all that and We can do lots and lots more and we'll see the lots lots more Throughout the video, but as a simple example imagine we have these two arrays One thing that we can do that's really nice in NumPy is that if we try to multiply these one item at a time We could do that in in lists you couldn't multiply one in one three and two five and three etc, but when we do the exact same computation within NumPy it allows us to do these you know single value like itemwise Computations which is pretty neat and pretty useful. So that's one example And we'll see a lot more throughout the video. So applications of NumPy there's all sorts of applications I think the first one the kind of the first one that comes to my mind is that is a kind of a MATLAB replacement you can do all sorts of mathematics with NumPy I think I should say that I think the sci-py library Has even more mathematics like functions or whatnot so if NumPy isn't cutting it for you Try to look through the sci-py documentation You might be able to find even more, but yeah, it's pretty powerful the math that NumPy can do It's useful in plotting it is The back end of many different applications. So pandas which I've done a video on before it is just like the core Component of pandas library it really allows pandas to work If you've seen my connect for how to program that video I use NumPy to store the board and Then in future videos that I'm gonna do you can you can actually store images Through NumPy it's like png Images you can use NumPy to store all the information and like do all sorts of cool stuff that all post future videos on Let's see also another I think Useful reason to know NumPy is that it's kind of like pretty important for machine learning applications both directly and then also kind of indirectly because One of the key Libraries or key kind of concepts you learn with Machine learning is the idea of like tensors and Tensors are pretty connected to kind of like the tensor libraries are pretty similar to like the NumPy library It's just the way to store all sorts of values. So knowing NumPy will help you Kind of be able to do some stuff with machine learning All right to get started with the code the first thing you're going to do is import the NumPy library and Just so we're on the same page. I'm using a Jupyter notebook to use to code this up But you can use whatever editor you prefer also all of this code that I'll be going through will be on my GitHub And the link to that will be in the description Okay, so important on p as np if that works for you great if it didn't work You'll have to do a pip install So you can go ahead into your terminal and type in pip install numpy And so it's already installed for me So and if pip doesn't work for you try pip 3 install numpy that should work So the first thing that's important to know is how to initialize an array. So we'll just say that a equals np.array And then within this we just basically pass in a list So 123 this would be a one-dimensional array containing values 123 As you see And you can go ahead you're not using Jupyter notebooks in print a Okay, cool. So we could also initialize a little bit more complex arrays So we could do like a 2d array of floats and I could do that the following way I'm going to have a list within a list Ah, so here's some float and values and then we're going to make this two-dimensional. So here's some more float values And let's go ahead and print b Cool So now that we know how to initialize arrays Uh, and you can keep doing this like I can nest list within a list within a list create a three-dimensional array etc um Some other useful things to know about this is um, how do how do you get the dimension of your numpy arrays? So if I did a dot number dimensions So this tells me that it's One-dimensional for a and if I did b dot and m It would be two Shape is another important function. So get shape If we do the first one a dot shape. This is always the do Um, it's a vector So it's only to tell me the one dimension because it only has one dimension. So it's size three If I do b dot shape, it's going to tell me the rows in the column So this is two rows and three columns. So it should print out two by three As it does Okay, other things we want to know how much memory our numpy arrays take up so we can get the type and you also get the size so If we want to get the type we do just a dot type Uh, sorry a dot data type in 32 by default So even though these are small values by default it Specifies that it should take up four bytes or being in 32 if we wanted to specify what type we wanted to store So maybe we knew that we didn't have many like big values So we could do like an in 16 and so that would take up less size and you can see the difference in size on a set So right now it's in 16 and if I want to see the size there's a couple different uh, I guess important functions with this Uh, we can do eight item size. So this should tell me two bytes As it does if we left this as an int 32 It will tell me four bytes down here As it does Um, you can also do I think um, the total size Um, I guess eight dot size is Uh, the total number of elements so the total size would be eight dot size times eight dot item size Um, another way to do that is I think just number of bytes As you see that's the same thing and um You can also do this with b slight b dot item size These are floats and I believe that this is an eight byte type. So I do b dot item size as you see yet It's eight so floats are gonna be bigger than um um Flutes are bigger than integers Usually unless you define this as like an int 64 And so yeah, you really I usually don't even worry about the data type too much I don't specify it but if you really want to be efficient try to specify this so that fits all your data but um If yeah, I guess it fits all your data as tightly as possible. All right, so nothing we've gone through some of the basics Let's actually show how we access slash change specific elements rows columns etc So imagine we have the array There's gonna be a two dimension more array so I'm gonna make this kind of long and you'll see why in a second Okay, so this is a two by seven array If I print that out Okay, and I could prove that it's a two by seven by doing eight out shape. That's just a reminder um, so what do we want it to get this a specific element Well to do that we can use this notation of row comma column So this is the row index. This is the column index. So I could do something just like a um Let's say I wanted to get this 13 right here. Well, that would be in the second row but because we start Python indexing at zero be the first row and then the zero one two three four five fifth column So yeah, that gives us the 13 as you see down here And one thing that's kind of cool is you can also Use the negative notation it's similar to lists So I could also say the negative second element would be 13 as well because this would be negative one and then negative two So there's a couple different ways to do this, but we'll stick with the first one Okay, let's say we wanted to get a specific I can't spell row That's pretty straightforward as well So in this case if we wanted the first row we would do zero and then because we want all columns We use the basic slice syntax in which the lists and I can just do a single column and that will get me everything in the row That's nice. What if we want a specific column? Well, if you know how to do rows you probably know how to do columns a Let's say we wanted This row or this column right here three and ten that would be all the rows and then zero one two column That gives me the three ten and From here we can do even some more like tricky stuff. So uh We're just say getting a little more fancy And we have the Start index This is just a reminder start index and index and then finally the step size So if I wanted to let's say get Between the numbers two and six every other element. So two four and six Well to specify that I would do Well, they want the first row and then I want to start at the first element The two and I actually screwed that up. It should be one. So I start at the two then I want to end here at the six Which is the It's exclusive. So that would be Uh, I want to actually go to the six element and then I want to step by two because I wanted two four six So I do one six two and that gives me two four six and I call season negative here and do like negative two Ah, what happened there? Oh, so that was going backwards. I didn't want to change it there I wanted to change the six to be negative two Ah, okay, it's exclusive. So I wanted this to actually be negative one A little bit more of a fancy way to do that Okay, so that's how you access elements And then if we wanted to change something it's pretty straightforward to it's that I wanted to change that 13 that are originally accessed Well, I can just do Like 20 if I print out a now That original element that was 13 is now 20 And you can do the same thing for um Series of numbers. So like for an entire column. Let's say we want to replace this 310 column I would do something like a colon 2 Equals let's say I wanted it to be all fives I could start like this And as you see it's all five five five and then if I wanted it to be two different numbers You just kind of specify the same shape as what you've sub sequenced. So I'd be like one two So now you see that we have a one two in that position Really quickly. I just show a 3d example If I had a 3d so we'll say d equals Numpy array of all of this and if I print B So if we want to get a specific element here The recommendation I have is work outside in so work outside in So let's say I wanted this for right here Well the farthest outside would be which one of these do I want and I want the first sets I want this area right here So if I wanted that I would do B zero and then now that I'm in here I want the second row So I want the three four so that would be one and now that I'm within this I want the first Uh or the second yeah the second element but the first index Like that so that gives me the four and you can do similar type stuff with like the colons in here So each one of these dimensions that you're indexing you can be all fancy with How you access elements so I can do something like this and You know get three four seven eight and you can kind of play around with this and see how Changing different things changes what you get And if you wanted to replace in this case Um Basically just have to create a sub sequence that's the same dimension So if I did B one This it gives me three four seven eight. Let's say I wanted to change that to nine nine eight As long as it's the same dimension It's gonna work so nine nine eight But I try to like do something like nine nine nine eight. It's gonna have an error All right, so that's the basics of indexing I think by the at the end of the video I'll do a little like um Challenge problem on like some advanced indexing so look at the end of the video for that All right next let's go through how to initialize all sorts of different types of arrays so the start off let's uh initialize in all zeros matrix um And to do that there's a nice built-in function called np.0s And we can first I guess actually all we really need to do is specify a shape So I did like np.0's five. It's gonna just give me a vector of five like five but I also can pass in a More complex shape so if I wanted it to be like a two by two or two by three let's say As you see there I could do three dimensional two by three by three Could even do four dimensional life wanted to two by three by three by two It gets pretty crazy, but yeah, uh you can do all sorts of zeros with that Um next let's do an all ones matrix pretty similar to the last one and p dot ones of Let's say four by two by two And there you go and you're getting also specify the data type here So if you wanted like all ones but in 32 Uh, you can go ahead and do that. So all ones uh all zeros However, you might want to initialize some matrix that's not uh ones or zeros and the other number So for that you can do np.4 And this one takes in two parameters. So the first is the shape so two by two and then the next is the value. So if I wanted all 99s That is a two by two with 99 another useful And you can you know that has a data type two. So if I wanted that to be float 32 There you go And I'll put a link in the description to a list full of these like array creation routines Uh useful to know is there's also this full like um There's this full like method and basically that just allows us to take a shape that's already built So that's imagine we wanted to reuse that um This array that we i guess had in in the last section a Well, I think it's still loaded in there. Just make sure Well, I can pass in and make a Array that's the same size size Uh of fours. Let's say by doing full Like All right, actually, I think I don't even have to pass in e.shaped I just have to pass in a There you go. If I didn't use full like I would have to do full of A dot shape. I don't know if that's that useful for you, but I guess it's potentially good to know Okay, next one. Let's say we wanted to initialize a Array or a matrix of random numbers. So random decimal numbers to start To do that we do np dot random dot random um and we specify the shape So let's say four by two Uh, I know what I'm doing wrong Uh Ha Actually confused Tooples state Oh Okay, yeah, this one's a little bit different. So instead of passing in a toople You can pass in directly the integers you want to The integers of the shape. So it's a kind of a weird thing to remember So if I did the four by two in this way, I would actually pass it in like that And when you get errors like this oftentimes you can just do a quick google search And realize that that's what you need to do. So I can even keep going so I can do a four by two by three Uh random numbers between zero and one I could also pass in something like A dot shape. I don't know if this would work. Let's try Yeah, so if you wanted to pass in like a shape you can do random sample A dot shape And that now you see gives us the same shape as our a from up here So yeah, Rand and then there's random sample which is another method We'll keep it as a random four by two Okay, whatever you didn't want just decimal numbers, but you wanted random like integer values Well to do that we can do random dot Rand I'm getting NP dot random dot Rand int And in this one we're going to pass in the start value or if you don't specify a start value It's going to just start at zero um And so if you don't specify a shape then it's just going to do one number. So let's say we wanted a three by three Yeah, what did I do wrong And this is not shaped actually size And yet all the documentation has these like you know you're not expected to memorize all of these things What I think it is helpful to see is that you See that you can do these types of things so like when you're thinking about a problem You can like kind of point back like oh, I remember that that's possible Maybe do a Google search on how to get it, but yeah random dot Rand int 07 With size 3 by 3 is here Could also specify like a different parameter. So let's say I wanted 4 to 7 And I think and if I keep running this to it's kind of cool. You can see it changing And so it looks like that 7 is exclusive. So if I wanted it included 7 I would stop a little bit later You'd also throw in like negative numbers here Cool All right What else other than a random integers? Maybe you wanted to do like the identity matrix. Let me do identity a three This one only needs one parameter because the identity matrix Look by its nature is going to be a square matrix What else is useful Maybe it's useful to repeat a array a few times so to do that you could do say we had the array um 123 Let's say I wanted to repeat that three times Passing the array you want to repeat and then let's print our one see what happens Okay And then if I specify the axis equals 0. I don't know did do anything Uh what I can do is make this a two-dimensional array. I think because it was a vector It didn't do what I wanted to what I wanted to do is 123 or 123 123 123 So if I wanted to do that Now I made this a two-dimensional array and it will repeat the inner part On the zero of the axis so we're basically making it rows There you go. So if I made this Um equal to one that's going to be what we saw before Cool Okay, so next here's a picture of an array. I want you to try to initialize using everything that we kind of just went through So all these different methods So look at this picture and then try to put it together without just mainly typing out all the numbers because you could imagine like This isn't too too big, but if you got into a matrix that was massive You'd want to know how to build it up using these kind of like fundamental concepts Okay, so here's a solution to that so I can do output equals I'm going to start with making everything ones So ones and it's going to be a five by five of ones um Print output So this is what I have now Okay, and now basically what we're going to do is fill in this middle part with zeros So Z I'm going to just say equals np dot zeros and that's going to be a three by three And if I print Z now we have this Now what I can do is fill in the middle element so that's one one with a nine And now if I print zero we get this and then finally we need to replace the middle part of the ones matrix So output the middle part so that's going to be the first row to the third row So I want the First row to the third row and then I want the same thing with columns because it's the middle first column to the Third column and actually this is exclusive value so it needs to go to four and that's going to equal um Z And now what happens when I print out but Is yay we got what we're looking for and actually one thing that I think it's nice is Instead of using four I could also do negative one So basically the from the first element to the last element Uh do that and as you see it didn't change This last initialization I want to go through I guess is a little bit different It's uh over on the concept of copying but something you got to be really careful about So I'm just going to quickly mention it I want to do an explanation once there you go um um okay, so imagine we have two Arrays or we have one array Uh, let's call it a And so now a is just a normal array as you can see and let's say we want to make be a direct copy of a So now I'm going to just do b equals a And then print out b and as you can see It's still one two three and so I'm like okay. I have this copy like things are cool. It's fine I want to change the first element and b. So I'm going to do b zero equals 100 Here's the issue I print out b looks good The issue lies in if I print out a Look what happens I just printed out a and a now has A 100 instead of the one two three that I initially set it as and that's because when we did b equals a we just set that the The variable name b points to the same thing as a does we didn't tell like NumPy to make a copy of what is the contents of a So that's that's why though because we're just pointing at the same exact thing that a is pointing when we change the value It also changes the value of a so if we want to prevent that we can use this dot copy function. Oh, sorry. I shouldn't do it yet um b equals a dot copy And then when we run the cell as you can see one two three Still there because now we're just copying the contents of what's in a And if I print b It has the 100 200 100 two three. Okay, so one of the big uses of numpy is all the math capabilities it offers So just to kind of show us some of that One thing that it can do is element wise We'll just make those four values element wise addition subtractions element wise. I guess arithmetic so here we have a print out a And if I wanted to do something like a plus two um, adds two to each element you can do a minus two Stractor from each element a times two As you can see a divided by two um Divided everything by two One thing to note with and you can also do stuff like a plus equals two So now I've printed out a in this column Uh, it's going to be two plus everything It's kind of cool. You can do like the same type of math that you can do in uh, Python You could also create another array and p dot array That's like let's say uh one zero one zero I could do something like a plus b That should be two two four four Oh, and because I added I already wrote this okay two two four four like we expect So all sorts of useful things you could even do like a to the second power 149 16 and that might have made it a bigger data type. I'm not sure cool We can do stuff like Take the sign of all the values. So let's say we had a we do mp dot sign pass and a Use us all the sign is the weight of all those values which You know and you have like Co-sign of all those values all sorts of useful things that you can form on an entire array or entire matrix all at once And if you want all of the different things that you can do um, I'll paste in a link Here this will all be part of the as I mentioned before I have this on my github So if you look in the description you can find this exact notebook Um, so yeah look up the routines right here for math all sorts of cool stuff All right moving on we're gonna still be in math, but let's jump into Linear algebra type stuff. So here we are doing linear algebra Okay, so this is kind of like basic All sorts of functions you can do on elements Linear algebra. So this is like really I feel like when I'm using that lab It would be doing these linear algebra type stuff. So let's say we have two matrices And the big difference with linear algebra is like we're not doing element wise. So like in this case this b We're doing element wise computation. So like eight times b Uh In you know linear algebra you're trying to multiply matrices and that's a different process. So let's say we have um Two matrices. We'll have a and I'm going to use the syntax we learned about earlier I want to say this is a two by three matrix of all twos Um, they're actually let's make this two by three matrix of ones So we have a as you can see and then we'll have um B which is equal to np dot full It's going to be a three by two And it's going to be of value two So if I print out b Now we have this and if you remember linear algebra you have to have the columns of the first matrix be the equal to the rows of the second one so as you can see this has three columns and this has three rows So we're good there. So we would multiply this row by this column um, and you know you do the the process of my trigon multiplication I don't walk through the whole thing but we should end up with a two by two matrix at the end if we want to do um matrix multiplication and it doesn't just automatically refer if you try to do eight times b It's not going to work because these are different sizes So what we can do is np has a matrix multiply function and if I pass an a then pass an b we get 6666 so to say enough sixes i don't know but uh, yeah it uh multiply those two matrices um, you know, and if i try to switch up this dimension in the middle Uh, it's not going to work because it's now incompatible uh Yeah, that's matrix multiplication you can also want to do maybe some other stuff with matrices So let's imagine i wanted to create the earth find the um Let's say determinant of a matrix so we could as a sanity check, you know, make c equal the identity matrix And if you are familiar with learning algebra you know that the identity matrix has a determinant of one um, so if i do linear algebra dot determinant of c we should get one One point now as we get so find the determinant You know, and there's all sorts of other good things like eigenvalues You know the inverse of a matrix so what What do you multiply by a matrix to get the identity matrix? um And so yeah all sorts of good stuff on that like i guess i'll do um And if you want to have all this information on the other types of linear algebra stuff Here is some useful information uh, definitely go to this link and as i've said a couple times in this video Uh, this notebook is on my github page so you can find all of this there But yeah, there's so many different things that you can do with matrices and linear algebra using the numpy library Okay, continuing onwards. Let's look at um some statistics with um, numpy So kind of the easiest things we might think about when we think about Sorry, um, statistics. There's like min, min, max, etc So let's say we have this array Um, so let's say we want to take the min of it. You can just do np.min of stats That's going to give us the one that you see there you can do np max of stats um Six you could also do it on like a row basis. Sometimes it actually equals one That's going to give me the min of the first row and the min of the second row Or maybe this is a better way to see it if i said x is equal to zero Well, it's going to give me all the values that are up top here because those are all the the min's Uh, so yeah, you can do all sorts of cool stuff with min and max with this um Same thing with max. Let's say x is equal to zero um Actually, you could lose one three and six is the biggest value Three is the biggest value and the six is the biggest value You can also do np.sum of stats if i do it Just as is is going to sum up all of the elements in the Matrix and then same thing i can do row or calling so Actually equals zero is going to add up all these terms going downwards Next, let's talk a little bit about reorganizing arrays So kind of the i would say the key method within reorganizing arrays. So if i have the array i'm going to call it before And let's say that is equal to This value right here So we have before how print before out Looks like that. So let's say we wanted to instead of this Shape that it currently has which is a two by four um Let's say we wanted to make it a I don't know a 8 by one or something or maybe a four by two um or a yeah, also it's a different things we could do i'll start with a by one. So we have before Uh, and if we wanted to make it something else we can do after equals Uh before dot reshape and then we pass in the new size we want it to have So if we wanted it to be an 8 by one You can pass it in like that and we can print out after As you can see it's an 8 by one now I could also say maybe i wanted it to be a four by two So now you got that you could even pass it in as a two by two by two as long as it has the same amount of values like it's fair game so as you see Two by two by two still works with the reshape Uh, what doesn't work is like if i wanted it to be two by three um, the values don't fit in so when you get errors but using the reshape it's usually because There's a mismatch between the shape you're trying to resize it to versus the original shape I'm moving onwards. Let's look at vertical stacks. So vertically stacking um vectors or matrices And you know Dimensions are important in vertical stack as well So vertical stacking matrices. Let's say we had these two arrays If i wanted to stack um, you know, 12345 on top of 5678 i can do np.v stack I can pass in v1 v2 And as you see now they're part of the same matrix And 12345 is on top of 5678 What i can even do is keep passing these in so let's say i wanted like three copies of This 5678 and only one copy of this or i could enter tweet weave them That's a vertical stack Horizontal stacks are pretty similar and also note here like i can't do that the size is mismatch Mitch miss match So yep horizontal stack very similar Um, let's see we had um We'll use a sub notation we've learned before we had these two matrices Um, so if i printed out h1 you got like that and then h2 is this Well, I want h2 to be on the back of h1. I can just do an mp.h stack horizontal stack And that will be h1 and h2 And that did not work because i did not surround this in parentheses Either parentheses or brackets i think people will work. Yeah There you go. So now we've Horizontal stack to the zeros on top of the ur to the right of the ones All right, let's get into some miscellaneous things uh, so first off let imagine you have uh, you know some sort of text file a hell sorts of data and For whatever reason you choose you don't want to use pandas but you want to load all that data from that file into a numpy array Well, we can do that without too much trouble. So I have this um Text file that i created as you can see here. This is on my github page Uh, you can download it there. This is just really simple data, but it shows kind of what you can do with it all delimited by commas called data txt um, what i can do is i can do MP and i can use this function called gen from text And i pass in the name of the file which is data.txt and then i pass in the delimiter Which is the separator and that's a comma and if i do that I see that i get that data that i just showed you um You get that i can increase the zoom here I Get that um as an array. So that's pretty nice. So Uh, I'll just call this file data equals And file data Yeah, one thing you notice though is it automatically cast it to a um float type And what if i wanted it to be an integer well i can do another function as type Which basically copies all the data into a whatever Format you specify. I'll say in 32 And as you can see now all of this stuff is here and if i go ahead and print file data now It is back to what we had originally and the reason that's back is that this actually makes a copy because the float type and the in 32 type are different sizes. It can't just like in place Um copy everything it doesn't really make sense to So if i did file data equals file data Uh dot as type Into 32 and then print it out file data As you can see now it's all float. So that's how you load data from a file And you can change up this delimiter based on how your data is split But i think that this gen from text will handle your Uh new line breaks properly if that's how it's formatted Um right in the comments if you have any questions about this Okay, the second thing i want to go through is um what happened there I didn't want that to be marked down Um the second thing i want to go through with this miscellaneous section is some advanced Indexing so there's some really cool stuff you can do with numpy uh i'm going to say Boolean masking and advanced indexing So what can we do here? So let's say i wanted to learn Where in file data The value is greater than 50 so if i just type in file data greater than 50 Uh, it's pretty cool that you get False or true based on whether that specific location was greater than 50 So as you can see there's four falses and then a true if we go to our data four falses and then 196 is in fact greater than 50 So that's like one way and you can do all sorts of cool stuff with this like you do greater than equal to you know All sorts of different combinations Uh, one thing that's pretty neat is you can do file data and then you can index based on Where it is greater than 50 Uh, and by doing this you grab only the Values that actually have a value greater than 50 So that is pretty cool and kind of the reason that this right here works is that one thing I did not mention until now um is that you can Can index with a list and numpy which is pretty cool. So you have the array uh, one two three four five six seven eight nine And I wanted to say the zeroth spot the second spot and then the last spot I could do MP or let's say that this is a I could do A of 0 1 And or I wanted two three and nine so I would do one two and then eight As you see that gives me two three and nine I passed in a list and it indexed those spots So basically it also works if you like had choosing false and is it like Basically if it is true then it knows to take it if it's false does it so that's why this up here works um We could do all sorts of other things so let's say um I wanted to figure out If any value in any of these columns was greater than 50 so I can do a NP dot any File data greater than 50 and the axis of zero so that should tell me like if we looked downwards On all of these are any of the values greater than 50 So it happens so false false false false true that's correct True these two values are greater than 50 this even though this one isn't um false true Yeah true true false true So this is telling us yeah where what columns have a value greater than 50 And I could also do NP dot all And as you see there's less truths in this case I think the only time that all of the values are greater than 50 are right here Yeah, you see there's one true in the fifth spot which corresponds to this right here I what else can we do with this um If you did access equals one It's gonna be the rose You can also do multiple conditions so I could do like I want file data to be greater than 50 And let's say file data is less than 100 and this syntax is very similar to pandas here And as I said before numpy builds is what's the base of pandas so it makes sense Uh, no The file truth value of an array with more than one element is ambiguous. How do I do this Think if I do something like this it will work Not positive let's see That would have been no I need to end it Yeah, cool. So this is all the values that are Greater than 50 but less than 100 so like the first true should happen at the sixth spot one two three four five six as you see Uh, and I could do something like All the spots if I wanted to make all this Not so this means not greater than 50 and less than 100 this is gonna be the reverse of what we just did So yeah now the um Six spot is the first false So this meant not so yeah all sorts of cool stuff you can do with this boolean masking and advanced indexing I mean yeah any sort of like condition. I'll put a link and some more information about this All right quick little quiz on uh indexing this is kind of using all sorts of advanced stuff that you just learned about last section include and then also like some of the original stuff So first question uh Basically pause the video after I ask it and then try to figure out what the command would be So we have this matrix and how would you index this part of the matrix? So this is the Second and third row and the first and second column or zeroth and first column so it looks something like this Rose columns next question. How would you index this? This is something we haven't done before But you potentially with that last section might have an idea if not no worries So to do this one um You need to use two different lists within your indexing So it's gonna look something like this We need the zeroth first second and third row And then the first second third and fourth columns. That's what that is and then final question How would you index this? This is like also something we haven't immediately looked at but you might be able to get Especially with that last one Take a second All right, that would look something like this Where you get the zeroth fourth and fifth rows zero fourth and fifth rows and then you want columns three onwards. So this would Like three onward works you could also do like three to five You'd also do three or like a list of three four, but yeah, that's one way to do it Fun little quiz. I don't know. It's I guess good to revisit this type of thing and like think critically about it All right, thank you guys very much for watching. I think this is all I have for this video peace out